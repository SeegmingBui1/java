public class bitop {
    static public void main(String [] args) {
        //位运算符直接操作内存的位
        //正数直接使用二进制
        //负数操作的是补码
        byte a = -5, b = 3;

        /* {
         * 3 0000 0011
         * 5 0000 0101
         *     5 >> 1      右移, 丢弃最右边的位数，前面补符号位
         *         0000 0010 = 2
         *     5 >>> 1     右移, 丢弃最右边的位数，前面补0
         *         0000 0010 = 2
         *     5 << 1      左移, 丢弃最左边的位数，后面固定补0
         *         0000 1010 = 10
         *     5 ^ 3       异或 两个数相同为0, 不同为1
         *         0000 0011
         *         0000 0101
         *         0000 0110 = 6
         *     5 & 3       位与 两个数都为1才为1, 否则为0
         *         0000 0011
         *         0000 0101
         *         0000 0001 = 1
         *     5 | 3       位或 只要两个数其中一个为1即为1
         *         0000 0011
         *         0000 0101
         *         0000 0111 = 7
         *     ~5
         *         0000 0101
         *         1111 1010
         *         1000 0110 -6
         *
         }*/

/*
 *         -5  1111 1011
 *         3   0000 0011
 *
 *             -5 >> 1  1111 1101 = -3
 *             -5 >>> 1 0111 1101 = 0x7d
 *             -5 << 1  1111 0110 = -10
 *             -5 ^ 3
 *                  1111 1011
 *                  0000 0011
 *                  1111 1000 = -8
 *             -5 & 3
 *                  1111 1011
 *                  0000 0011
 *                  0000 0011 = 3
 *             -5 | 3
 *                  1111 1011
 *                  0000 0011
 *                  1111 1011 = -5
 *              ~-5
 *                  1111 1011
 *                  0000 0100 = 4
 */

        System.out.printf("a >> 1 = %d\n", a >> 1);
        System.out.printf("a >>> 1 = %x\n", (byte)(a >>> 1));
        System.out.printf("a << 1 = %d\n", a << 1);
        System.out.printf("a ^ b = %d\n", a ^ b);
        System.out.printf("a & b = %d\n", a & b);
        System.out.printf("a | b = %d\n", a | b);
        System.out.printf("~a = %d\n", ~a);

    }
}
